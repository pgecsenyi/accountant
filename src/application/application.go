package application

import (
	"bll"
	"dal"
	"flag"
	"log"
	"os"
	"util"
)

const taskCalculate = "calculate"
const taskCompare = "compare"
const taskExport = "export"
const taskImport = "import"
const taskVerify = "verify"

// Application Contains main application logic.
type Application struct {
	config  configuration
	logFile *os.File
}

type configuration struct {
	task            string
	algorithm       string
	inputChecksum   string
	inputDirectory  string
	outputChecksum  string
	outputDirectory string
	outputNames     string
	basePath        string
	filter          string
	missingOnly     bool
	logPath         string
}

// Initialize Initializes the application.
func (app *Application) Initialize() {

	defaultConfig := configuration{taskCalculate, dal.SHA1, "", "", "", "", "", "", "", false, ""}
	app.parseCommandLineArguments(defaultConfig)
	app.verifyConfiguration()
}

// Execute Executes the application.
func (app *Application) Execute() {

	app.initializeLog()
	defer app.cleanUp()

	db := dal.NewDb()
	if app.config.task == taskCalculate {
		calculator := bll.Calculator{
			app.config.inputDirectory, app.config.outputChecksum, app.config.basePath, app.config.inputChecksum}
		calculator.RecordChecksumsForDirectory(&db, app.config.algorithm)
	} else if app.config.task == taskCompare {
		comparer := bll.Comparer{
			app.config.inputDirectory, app.config.inputChecksum,
			app.config.outputNames, app.config.outputChecksum,
			app.config.basePath}
		comparer.RecordNameChangesForDirectory(&db, app.config.algorithm)
	} else if app.config.task == taskExport {
		exporter := bll.NewExporter(
			app.config.inputChecksum, app.config.outputDirectory,
			app.config.filter, app.config.basePath)
		exporter.Convert(&db)
	} else if app.config.task == taskImport {
		importer := bll.NewImporter(app.config.inputDirectory, app.config.outputChecksum)
		importer.Convert(&db)
	} else if app.config.task == taskVerify {
		verifier := bll.NewVerifier(app.config.inputChecksum, app.config.basePath)
		verifier.Verify(&db, app.config.missingOnly)
	}
}

func (app *Application) parseCommandLineArguments(defaultConfig configuration) {

	algorithm := flag.String("alg", defaultConfig.algorithm, "The algorithm used to calculate new checksums.")
	basePath := flag.String(
		"bp",
		defaultConfig.basePath,
		"The first part of the path that will not be stored in the output.")
	filter := flag.String("filter", defaultConfig.filter, "A filter for exported filenames.")
	inputChecksum := flag.String(
		"inchk",
		defaultConfig.inputChecksum,
		"The name of the input CSV containing checksums.")
	inputDirectory := flag.String(
		"indir",
		defaultConfig.inputDirectory,
		"The source directory for which the checksums will be calculated (or will be compared). Or the directory"+
			" containing the files to import.")
	logPath := flag.String(
		"log",
		defaultConfig.logPath,
		"Path of the log file. Optional, by default the program will print log messages to the standard error output.")
	outputChecksum := flag.String(
		"outchk",
		defaultConfig.outputChecksum,
		"The name of the output CSV file containing checksums.")
	outputDirectory := flag.String(
		"outdir",
		defaultConfig.outputDirectory,
		"The name of the directory containing exported files.")
	outputNames := flag.String(
		"outnames",
		defaultConfig.outputNames,
		"The name of the output containing new file name and old filename pairs.")
	task := flag.String(
		"task",
		defaultConfig.task,
		"The task to execute: calculate, compare, import, export or verify. The first one calculates checksums for a"+
			" directory and stores the results in a CSV. The second compares stored checksums with the checksums of"+
			" the files in the given directory and stores filename matches. The third imports checksums from files"+
			" generated by Linux utilities or Total Commander. The fourth exports to Total Commander's formats. The"+
			" fifth verifies checksums for the files listed in the given CSV.")
	missingOnly := flag.Bool(
		"missingonly",
		defaultConfig.missingOnly,
		"For calculate task it means that calculation is requested for those files only that do not have a checksum"+
			" stored yet. In case of the verify task, set it to true if you would like to verify only if each file"+
			" exists.")

	flag.Parse()

	app.config = configuration{
		*task, *algorithm,
		*inputChecksum, *inputDirectory,
		*outputChecksum, *outputDirectory, *outputNames,
		*basePath, *filter, *missingOnly, *logPath}
}

func (app *Application) verifyConfiguration() {

	if app.config.task == taskCalculate {
		app.stopIfInputDirectoryDoesNotExist()
		if app.config.missingOnly {
			app.stopIfInputChecksumDoesNotExist()
		} else {
			app.config.inputChecksum = ""
		}
	} else if app.config.task == taskCompare {
		app.stopIfInputChecksumDoesNotExist()
		app.stopIfInputDirectoryDoesNotExist()
	} else if app.config.task == taskExport {
		app.stopIfOutputDirectoryDoesNotExist()
	} else if app.config.task == taskImport {
		app.stopIfInputDirectoryDoesNotExist()
	} else if app.config.task == taskVerify {
		app.stopIfInputChecksumDoesNotExist()
	} else {
		log.Fatalln("Unknown task.")
	}
}

func (app *Application) initializeLog() {

	if app.config.logPath == "" {
		return
	}

	file, err := os.OpenFile(app.config.logPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
	if err != nil {
		app.logFile = nil
	}

	app.logFile = file
	log.SetOutput(app.logFile)
}

func (app *Application) cleanUp() {

	if app.logFile != nil {
		app.logFile.Close()
	}
}

func (app *Application) stopIfInputChecksumDoesNotExist() {

	if app.config.inputChecksum == "" || !util.CheckIfFileExists(app.config.inputChecksum) {
		log.Fatalln("Input file does not exist.")
	}
}

func (app *Application) stopIfInputDirectoryDoesNotExist() {

	if app.config.inputDirectory == "" || !checkIfDirectoryExists(app.config.inputDirectory) {
		log.Fatalln("Directory " + app.config.inputDirectory + " does not exist.")
	}
}

func (app *Application) stopIfOutputDirectoryDoesNotExist() {

	if !checkIfDirectoryExists(app.config.outputDirectory) {
		log.Fatalln("Directory " + app.config.outputDirectory + " does not exist.")
	}
}

func checkIfDirectoryExists(path string) bool {

	if stat, err := os.Stat(path); err == nil && stat.IsDir() {
		return true
	}

	return false
}
